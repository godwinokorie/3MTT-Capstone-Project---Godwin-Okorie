# -*- coding: utf-8 -*-
"""3MTT Capstone Project Godwin Okorie.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S0mvIQxxsnr1Mo3wdfIoHfI0IocBHaHq
"""

from google.colab import files
files.upload()

import os
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d allen-institute-for-ai/CORD-19-research-challenge

!ls

from google.colab import files
files.upload()

import os
print(os.listdir('/content'))

#import necessary libraries
import pandas as pd # Add this line to import pandas with the alias pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from statsmodels.tsa.holtwinters import ExponentialSmoothing

df1 = pd.read_csv('country_wise_latest.csv')
df2 = pd.read_csv('covid_19_clean_complete.csv')
df3 = pd.read_csv('day_wise.csv')
df4 = pd.read_csv('full_grouped.csv')
df5 = pd.read_csv('worldometer_data.csv')

"""***Inspect the datasets to understand their structure. Clean the Data***"""

# Inspect each dataset
print("Country-wise Latest Data:\n", df1.info(), "\n")
print("COVID-19 Clean Complete Data:\n", df2.info(), "\n")
print("Day-wise Data:\n", df3.info(), "\n")
print("Full Grouped Data:\n", df4.info(), "\n")
print("Worldometer Data:\n", df5.info(), "\n")

# Preview the first few rows of each dataset
print("Country-wise Latest Preview:\n", df1.head(), "\n")
print("Day-wise Data Preview:\n", df3.head(), "\n")

# Merge df2 with selected columns from df5
df = df2.merge(df5[['Country/Region', 'Continent', 'Population', 'WHO Region']],
               on='Country/Region', how='left')

# Check if the columns exist
print("Columns in df after merge:", df.columns)

# Drop rows with missing values
if 'WHO Region' in df.columns and 'Date' in df.columns:
    df.dropna(subset=['Continent', 'Population', 'WHO Region', 'Date'], inplace=True)
else:
    print("One or more columns are missing. Check your data.")

# Display the result
df.head()

df_fill=df.fillna({
    'NewCases':0,
       'TotalDeaths':0,
    'NewDeaths':0,
    'TotalRecovered':0,
    'NewRecovered':0,
       'ActiveCases':0,
    'Serious,Critical':0,
    'Tot Cases/1M pop':0,
    'Deaths/1M pop':0,
       'TotalTests':0,
    'Tests/1M pop':0, })
df_fill.head()

#change date column from object to date
df_fill['Date'] = pd.to_datetime(df_fill['Date'])
df_fill['Date'] = pd.to_datetime(df_fill['Date'], errors='coerce')
df_fill.dtypes

df_fill.duplicated().sum()

df_d = df_fill.drop_duplicates()

df_d.duplicated().sum()

df_d.shape

df_d.columns

df_d.describe()

"""***Exploratory Data Analysis***"""

# @title Date vs Lat

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['Date']
  ys = series['Lat']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = df.sort_values('Date', ascending=True)
for i, (series_name, series) in enumerate(df_sorted.groupby('WHO Region_x')):
  _plot_series(series, series_name, i)
  fig.legend(title='WHO Region_x', bbox_to_anchor=(1, 1), loc='upper left')
sns.despine(fig=fig, ax=ax)
plt.xlabel('Date')
_ = plt.ylabel('Lat')

# @title WHO Region_x vs Long

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(df['WHO Region_x'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(df, x='Long', y='WHO Region_x', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

# @title WHO Region_y vs Lat

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(df['WHO Region_y'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(df, x='Lat', y='WHO Region_y', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

# @title Deaths

from matplotlib import pyplot as plt
df['Deaths'].plot(kind='line', figsize=(8, 4), title='Deaths')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title Lat vs Long

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='Lat', y='Long', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title WHO Region_x vs Continent

from matplotlib import pyplot as plt
import seaborn as sns
import pandas as pd
plt.subplots(figsize=(8, 8))
df_2dhist = pd.DataFrame({
    x_label: grp['Continent'].value_counts()
    for x_label, grp in df.groupby('WHO Region_x')
})
sns.heatmap(df_2dhist, cmap='viridis')
plt.xlabel('WHO Region_x')
_ = plt.ylabel('Continent')

# @title Deaths vs Recovered

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='Deaths', y='Recovered', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title Confirmed vs Deaths

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='Confirmed', y='Deaths', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title WHO Region_y

from matplotlib import pyplot as plt
import seaborn as sns
df.groupby('WHO Region_y').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title WHO Region_x

from matplotlib import pyplot as plt
import seaborn as sns
df.groupby('WHO Region_x').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title Deaths

from matplotlib import pyplot as plt
df['Deaths'].plot(kind='hist', bins=20, title='Deaths')
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title Confirmed

from matplotlib import pyplot as plt
df['Confirmed'].plot(kind='hist', bins=20, title='Confirmed')
plt.gca().spines[['top', 'right',]].set_visible(False)

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd # Import pandas for data manipulation

# Calculate the correlation matrix for numerical columns in df1
# Select only numerical columns using select_dtypes
numerical_df1 = df1.select_dtypes(include=['number'])
correlation_matrix = numerical_df1.corr()

# Display the correlation matrix as a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap="coolwarm", cbar=True)
plt.title('Correlation Matrix of COVID-19 Metrics')
plt.show()

# Extract strongly correlated pairs
strong_correlation = correlation_matrix[(correlation_matrix >= 0.7) | (correlation_matrix <= -0.7)]
print(strong_correlation)

"""For Global Trends (df3)
Use the day_wise.csv dataset to analyze cumulative cases and deaths over time.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Convert 'Date' column to datetime
df3['Date'] = pd.to_datetime(df3['Date'])

# Plot global cumulative cases and deaths
plt.figure(figsize=(12, 6))
sns.lineplot(data=df3, x='Date', y='Confirmed', label='Cumulative Cases', color='blue')
sns.lineplot(data=df3, x='Date', y='Deaths', label='Cumulative Deaths', color='red')
plt.title('Global Cumulative COVID-19 Cases and Deaths')
plt.xlabel('Date')
plt.ylabel('Counts')
plt.legend()
plt.grid(True)
plt.show()

"""Use the worldometer_data.csv dataset for country-level analysis."""

# Filter top 10 countries by total cases
top_countries = df5.nlargest(10, 'TotalCases')

# Bar plot for total cases in top countries
plt.figure(figsize=(10, 6))
sns.barplot(data=top_countries, x='TotalCases', y='Country/Region', palette='viridis')
plt.title('Top 10 Countries by Total Cases')
plt.xlabel('Total Cases')
plt.ylabel('Country')
plt.grid(True)
plt.show()

"""Add a Case Fatality Rate (CFR) feature to the country_wise_latest.csv dataset and visualize the top 10 countries by CFR."""

# Calculate Case Fatality Rate
df1['CaseFatalityRate'] = (df1['Deaths'] / df1['Confirmed']) * 100

# Filter top 10 countries by CFR
top_cfr_countries = df1.nlargest(10, 'CaseFatalityRate')

# Bar plot for CFR in top countries
plt.figure(figsize=(10, 6))
sns.barplot(data=top_cfr_countries, x='CaseFatalityRate', y='Country/Region', palette='magma')
plt.title('Top 10 Countries by Case Fatality Rate (CFR)')
plt.xlabel('Case Fatality Rate (%)')
plt.ylabel('Country')
plt.grid(True)
plt.show()

"""Forecasting Global Cases with ARIMA (df3)
Use the day_wise.csv dataset to forecast global confirmed cases for the next 30 days.
"""

from statsmodels.tsa.arima.model import ARIMA

# Set 'Date' as the index and focus on 'Confirmed'
time_series = df3.set_index('Date')['Confirmed']

# Fit ARIMA model
model = ARIMA(time_series, order=(5, 1, 0))  # Parameters can be tuned
model_fit = model.fit()

# Forecast for the next 30 days
forecast = model_fit.forecast(steps=30)

# Plot observed vs forecasted data
plt.figure(figsize=(12, 6))
plt.plot(time_series, label='Observed', color='blue')
plt.plot(forecast, label='Forecast', linestyle='--', color='red')
plt.title('Forecasted Global COVID-19 Cases')
plt.xlabel('Date')
plt.ylabel('Confirmed Cases')
plt.legend()
plt.grid(True)
plt.show()

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import plot_tree

# Train the Random Forest model
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Visualize the first tree in the forest
plt.figure(figsize=(20, 10))
plot_tree(rf.estimators_[0], filled=True, feature_names=X_train.columns.tolist(), max_depth=3)
plt.title('Decision Tree Visualization (First Tree in Forest)')
plt.show()

from sklearn.metrics import mean_absolute_error
import numpy as np

# Assuming y_test is the actual values and y_pred is the predicted values
y_pred = rf.predict(X_test)

plt.figure(figsize=(8, 8))
plt.scatter(y_test, y_pred, alpha=0.6, color='blue')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], '--r', linewidth=2)
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title('Actual vs Predicted')
plt.show()

# Print performance metrics
print(f"Mean Absolute Error: {mean_absolute_error(y_test, y_pred)}")

"""Classify countries into High Severity or Low Severity based on their total cases using a Random Forest Classifier."""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score

# Define features and target
X = df1[['Confirmed', 'Deaths', 'Recovered']]
y = (df1['Confirmed'] > df1['Confirmed'].median()).astype(int)  # 1: High Severity, 0: Low Severity

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train Random Forest model
rf_model = RandomForestClassifier(random_state=42)
rf_model.fit(X_train, y_train)

# Evaluate model
y_pred = rf_model.predict(X_test)
print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Feature Importance
feature_importances = rf_model.feature_importances_
plt.figure(figsize=(8, 5))
sns.barplot(x=feature_importances, y=X.columns, palette='viridis')
plt.title('Feature Importance')
plt.xlabel('Importance Score')
plt.ylabel('Feature')
plt.grid(True)
plt.show()

"""Save the processed data and trained models for reuse."""

# Save processed datasets
df1.to_csv('processed_country_wise_latest.csv', index=False)
df3.to_csv('processed_day_wise.csv', index=False)

# Save the Random Forest model
import joblib
joblib.dump(rf_model, 'random_forest_model.pkl')
print("Model saved as 'random_forest_model.pkl'")

"""Forecast trends for 3 more years."""

from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

# Prepare the time-series data
df3['Date'] = pd.to_datetime(df3['Date'])
df3.set_index('Date', inplace=True)
time_series = df3['Confirmed']

# Fit ARIMA model
model = ARIMA(time_series, order=(5, 1, 0))  # Adjust (p, d, q) through tuning
model_fit = model.fit()

# Forecast for the next 1095 days (3 years)
forecast_steps = 1095
forecast = model_fit.forecast(steps=forecast_steps)

# Create a date range for the forecast
import pandas as pd
forecast_dates = pd.date_range(start=time_series.index[-1], periods=forecast_steps + 1, freq='D')[1:]

# Plot observed vs forecasted data
plt.figure(figsize=(14, 7))
plt.plot(time_series, label='Observed', color='blue')
plt.plot(forecast_dates, forecast, label='Forecast (Next 3 Years)', linestyle='--', color='red')
plt.title('Global COVID-19 Cases Forecast (Next 3 Years)')
plt.xlabel('Date')
plt.ylabel('Cumulative Cases')
plt.legend()
plt.grid(True)
plt.show()

